-- https://github.com/MaartenBaert/xormix/blob/master/vhdl/rtl/xormix32.vhd
-- Copyright (c) 2020-2021 Maarten Baert <info@maartenbaert.be>
-- Available under the MIT License - see LICENSE.txt for details.

-- This file was generated by `generate_vhdl.py`.
-- Revision: 1

library ieee;
use ieee.std_logic_1164.all;

entity xormix32 is
  generic (
    STREAMS : integer range 1 to 32 := 1
  );
  port (
    -- clock and synchronous reset
    clk : in std_logic;
    rst : in std_logic;

    -- configuration
    seed_x : in std_logic_vector(31 downto 0);
    seed_y : in std_logic_vector(32 * STREAMS - 1 downto 0);

    -- random number generator
    enable : in std_logic;
    result : out std_logic_vector(32 * STREAMS - 1 downto 0)
  );
end entity xormix32;

architecture rtl of xormix32 is

  type     salts_t is array(0 to 31) of std_logic_vector(31 downto 0);
  constant SALTS : salts_t := (
    x"198F8D32",
    x"46D9B8AC",
    x"57F90206",
    x"CB246290",
    x"5FDA94C2",
    x"B9969E83",
    x"990053FE",
    x"0CEF1F8B",
    x"9BAAFEFA",
    x"232B8463",
    x"0FC77197",
    x"D113A2D8",
    x"D6C99EF7",
    x"F3FB7189",
    x"9CEEB1DD",
    x"352DF180",
    x"FEED780C",
    x"EE211518",
    x"3AFACA18",
    x"95F13C50",
    x"D8449F2A",
    x"59752549",
    x"854F0980",
    x"234A07B4",
    x"51C0C69B",
    x"A71D489E",
    x"618CBC79",
    x"AB0E51E1",
    x"965C4507",
    x"E90488A4",
    x"73674EB7",
    x"00AF1456"
  );

  signal r_state_x : std_logic_vector(31 downto 0);
  signal r_state_y : std_logic_vector(32 * STREAMS - 1 downto 0);

begin

  result <= r_state_y;

  process (clk) is

    variable v_state_y : std_logic_vector(32 * STREAMS - 1 downto 0);

    variable v_mixin : std_logic_vector(31 downto 0);
    variable v_mixup : std_logic_vector(31 downto 0);
    variable v_res   : std_logic_vector(15 downto 0);

  begin
    if rising_edge(clk) then
      if rst = '1' then
        r_state_x <= seed_x;
        r_state_y <= seed_y;
      elsif enable = '1' then
        r_state_x( 0) <= r_state_x(11) xor r_state_x(24) xor r_state_x(22) xor r_state_x( 3) xor r_state_x(19);
        r_state_x( 1) <= r_state_x(25) xor r_state_x( 7) xor r_state_x(20) xor r_state_x( 2) xor r_state_x(26) xor r_state_x(28);
        r_state_x( 2) <= r_state_x( 8) xor r_state_x( 5) xor r_state_x(18) xor r_state_x(24) xor r_state_x( 4);
        r_state_x( 3) <= r_state_x( 8) xor r_state_x(22) xor r_state_x(26) xor r_state_x( 7) xor r_state_x(21) xor r_state_x(14);
        r_state_x( 4) <= r_state_x(30) xor r_state_x(26) xor r_state_x(25) xor r_state_x(14) xor r_state_x(24);
        r_state_x( 5) <= r_state_x(21) xor r_state_x(10) xor r_state_x(16) xor r_state_x(13) xor r_state_x( 5) xor r_state_x(17);
        r_state_x( 6) <= r_state_x(14) xor r_state_x(29) xor r_state_x(24) xor r_state_x(11) xor r_state_x(25);
        r_state_x( 7) <= r_state_x( 5) xor r_state_x(26) xor r_state_x(31) xor r_state_x(22) xor r_state_x(27) xor r_state_x( 7);
        r_state_x( 8) <= r_state_x( 0) xor r_state_x(17) xor r_state_x( 1) xor r_state_x(18) xor r_state_x( 8);
        r_state_x( 9) <= r_state_x(29) xor r_state_x( 0) xor r_state_x(21) xor r_state_x(26) xor r_state_x( 3) xor r_state_x(13);
        r_state_x(10) <= r_state_x(23) xor r_state_x(29) xor r_state_x(19) xor r_state_x(21) xor r_state_x(10);
        r_state_x(11) <= r_state_x(19) xor r_state_x(20) xor r_state_x( 4) xor r_state_x(18) xor r_state_x(15) xor r_state_x(10);
        r_state_x(12) <= r_state_x(28) xor r_state_x(29) xor r_state_x(24) xor r_state_x(19) xor r_state_x( 4);
        r_state_x(13) <= r_state_x(19) xor r_state_x( 6) xor r_state_x(27) xor r_state_x(12) xor r_state_x(11) xor r_state_x( 7);
        r_state_x(14) <= r_state_x( 1) xor r_state_x( 5) xor r_state_x( 3) xor r_state_x(30) xor r_state_x(25);
        r_state_x(15) <= r_state_x(22) xor r_state_x(12) xor r_state_x(11) xor r_state_x( 7) xor r_state_x(28) xor r_state_x( 1);
        r_state_x(16) <= r_state_x(16) xor r_state_x( 5) xor r_state_x(29) xor r_state_x( 2) xor r_state_x(14);
        r_state_x(17) <= r_state_x( 8) xor r_state_x(24) xor r_state_x( 0) xor r_state_x(23) xor r_state_x(31) xor r_state_x(26);
        r_state_x(18) <= r_state_x(15) xor r_state_x(17) xor r_state_x( 4) xor r_state_x( 9) xor r_state_x( 6);
        r_state_x(19) <= r_state_x(30) xor r_state_x( 9) xor r_state_x(18) xor r_state_x( 2) xor r_state_x(11) xor r_state_x( 6);
        r_state_x(20) <= r_state_x( 2) xor r_state_x(27) xor r_state_x(15) xor r_state_x(12) xor r_state_x(20);
        r_state_x(21) <= r_state_x(21) xor r_state_x(20) xor r_state_x(10) xor r_state_x( 6) xor r_state_x(31) xor r_state_x( 1);
        r_state_x(22) <= r_state_x( 9) xor r_state_x(29) xor r_state_x(15) xor r_state_x(27) xor r_state_x(16);
        r_state_x(23) <= r_state_x(29) xor r_state_x(10) xor r_state_x(31) xor r_state_x(30) xor r_state_x(13) xor r_state_x( 3);
        r_state_x(24) <= r_state_x(31) xor r_state_x(23) xor r_state_x( 6) xor r_state_x(24) xor r_state_x(17);
        r_state_x(25) <= r_state_x( 4) xor r_state_x( 8) xor r_state_x( 6) xor r_state_x(19) xor r_state_x(16) xor r_state_x( 9);
        r_state_x(26) <= r_state_x(23) xor r_state_x(22) xor r_state_x(15) xor r_state_x(28) xor r_state_x( 6);
        r_state_x(27) <= r_state_x(30) xor r_state_x( 9) xor r_state_x(10) xor r_state_x(28) xor r_state_x(18) xor r_state_x(15);
        r_state_x(28) <= r_state_x(25) xor r_state_x(20) xor r_state_x(19) xor r_state_x(12) xor r_state_x(28);
        r_state_x(29) <= r_state_x(13) xor r_state_x(10) xor r_state_x( 9) xor r_state_x( 8) xor r_state_x( 0) xor r_state_x(14);
        r_state_x(30) <= r_state_x(22) xor r_state_x(27) xor r_state_x( 3) xor r_state_x(13) xor r_state_x(23);
        r_state_x(31) <= r_state_x(12) xor r_state_x( 2) xor r_state_x(16) xor r_state_x( 1) xor r_state_x(17) xor r_state_x(23);

        for i in 0 to STREAMS - 1 loop
          v_mixin                              := r_state_x xor salts(i);
          v_mixup                              := r_state_y(32 * ((i + 1) mod STREAMS) + 31 downto 32 * ((i + 1) mod STREAMS));
          v_res( 0)                            := v_mixup( 0) xor (v_mixup( 6) and not v_mixup(16)) xor v_mixup( 9) xor v_mixup(15) xor v_mixin((i + 15) mod 32);
          v_res( 1)                            := v_mixup( 1) xor (v_mixup( 7) and not v_mixup(17)) xor v_mixup(10) xor v_mixup(16) xor v_mixin((i + 29) mod 32);
          v_res( 2)                            := v_mixup( 2) xor (v_mixup( 8) and not v_mixup(18)) xor v_mixup(11) xor v_mixup(17) xor v_mixin((i +  5) mod 32);
          v_res( 3)                            := v_mixup( 3) xor (v_mixup( 9) and not v_mixup(19)) xor v_mixup(12) xor v_mixup(18) xor v_mixin((i +  0) mod 32);
          v_res( 4)                            := v_mixup( 4) xor (v_mixup(10) and not v_mixup(20)) xor v_mixup(13) xor v_mixup(19) xor v_mixin((i + 16) mod 32);
          v_res( 5)                            := v_mixup( 5) xor (v_mixup(11) and not v_mixup(21)) xor v_mixup(14) xor v_mixup(20) xor v_mixin((i +  9) mod 32);
          v_res( 6)                            := v_mixup( 6) xor (v_mixup(12) and not v_mixup(22)) xor v_mixup(15) xor v_mixup(21) xor v_mixin((i + 26) mod 32);
          v_res( 7)                            := v_mixup( 7) xor (v_mixup(13) and not v_mixup(23)) xor v_mixup(16) xor v_mixup(22) xor v_mixin((i + 14) mod 32);
          v_res( 8)                            := v_mixup( 8) xor (v_mixup(14) and not v_mixup(24)) xor v_mixup(17) xor v_mixup(23) xor v_mixin((i + 13) mod 32);
          v_res( 9)                            := v_mixup( 9) xor (v_mixup(15) and not v_mixup(25)) xor v_mixup(18) xor v_mixup(24) xor v_mixin((i + 10) mod 32);
          v_res(10)                            := v_mixup(10) xor (v_mixup(16) and not v_mixup(26)) xor v_mixup(19) xor v_mixup(25) xor v_mixin((i + 19) mod 32);
          v_res(11)                            := v_mixup(11) xor (v_mixup(17) and not v_mixup(27)) xor v_mixup(20) xor v_mixup(26) xor v_mixin((i + 11) mod 32);
          v_res(12)                            := v_mixup(12) xor (v_mixup(18) and not v_mixup(28)) xor v_mixup(21) xor v_mixup(27) xor v_mixin((i +  2) mod 32);
          v_res(13)                            := v_mixup(13) xor (v_mixup(19) and not v_mixup(29)) xor v_mixup(22) xor v_mixup(28) xor v_mixin((i +  6) mod 32);
          v_res(14)                            := v_mixup(14) xor (v_mixup(20) and not v_mixup(30)) xor v_mixup(23) xor v_mixup(29) xor v_mixin((i +  8) mod 32);
          v_res(15)                            := v_mixup(15) xor (v_mixup(21) and not v_mixup(31)) xor v_mixup(24) xor v_mixup(30) xor v_mixin((i + 17) mod 32);
          v_state_y(32 * i + 31 downto 32 * i) := v_res & r_state_y(32 * i + 31 downto 32 * i + 16);
        end loop;

        for i in 0 to STREAMS - 1 loop
          v_mixin                              := r_state_x xor salts(i);
          v_mixup                              := v_state_y(32 * ((i + 1) mod STREAMS) + 31 downto 32 * ((i + 1) mod STREAMS));
          v_res( 0)                            := v_mixup( 0) xor (v_mixup( 6) and not v_mixup(16)) xor v_mixup( 9) xor v_mixup(15) xor v_mixin((i + 20) mod 32);
          v_res( 1)                            := v_mixup( 1) xor (v_mixup( 7) and not v_mixup(17)) xor v_mixup(10) xor v_mixup(16) xor v_mixin((i +  4) mod 32);
          v_res( 2)                            := v_mixup( 2) xor (v_mixup( 8) and not v_mixup(18)) xor v_mixup(11) xor v_mixup(17) xor v_mixin((i + 22) mod 32);
          v_res( 3)                            := v_mixup( 3) xor (v_mixup( 9) and not v_mixup(19)) xor v_mixup(12) xor v_mixup(18) xor v_mixin((i + 30) mod 32);
          v_res( 4)                            := v_mixup( 4) xor (v_mixup(10) and not v_mixup(20)) xor v_mixup(13) xor v_mixup(19) xor v_mixin((i + 31) mod 32);
          v_res( 5)                            := v_mixup( 5) xor (v_mixup(11) and not v_mixup(21)) xor v_mixup(14) xor v_mixup(20) xor v_mixin((i + 21) mod 32);
          v_res( 6)                            := v_mixup( 6) xor (v_mixup(12) and not v_mixup(22)) xor v_mixup(15) xor v_mixup(21) xor v_mixin((i + 24) mod 32);
          v_res( 7)                            := v_mixup( 7) xor (v_mixup(13) and not v_mixup(23)) xor v_mixup(16) xor v_mixup(22) xor v_mixin((i + 25) mod 32);
          v_res( 8)                            := v_mixup( 8) xor (v_mixup(14) and not v_mixup(24)) xor v_mixup(17) xor v_mixup(23) xor v_mixin((i + 18) mod 32);
          v_res( 9)                            := v_mixup( 9) xor (v_mixup(15) and not v_mixup(25)) xor v_mixup(18) xor v_mixup(24) xor v_mixin((i + 27) mod 32);
          v_res(10)                            := v_mixup(10) xor (v_mixup(16) and not v_mixup(26)) xor v_mixup(19) xor v_mixup(25) xor v_mixin((i + 28) mod 32);
          v_res(11)                            := v_mixup(11) xor (v_mixup(17) and not v_mixup(27)) xor v_mixup(20) xor v_mixup(26) xor v_mixin((i + 23) mod 32);
          v_res(12)                            := v_mixup(12) xor (v_mixup(18) and not v_mixup(28)) xor v_mixup(21) xor v_mixup(27) xor v_mixin((i + 12) mod 32);
          v_res(13)                            := v_mixup(13) xor (v_mixup(19) and not v_mixup(29)) xor v_mixup(22) xor v_mixup(28) xor v_mixin((i +  7) mod 32);
          v_res(14)                            := v_mixup(14) xor (v_mixup(20) and not v_mixup(30)) xor v_mixup(23) xor v_mixup(29) xor v_mixin((i +  1) mod 32);
          v_res(15)                            := v_mixup(15) xor (v_mixup(21) and not v_mixup(31)) xor v_mixup(24) xor v_mixup(30) xor v_mixin((i +  3) mod 32);
          r_state_y(32 * i + 31 downto 32 * i) <= v_res & v_state_y(32 * i + 31 downto 32 * i + 16);
        end loop;

      end if;
    end if;
  end process;

end architecture rtl;
